on:
  workflow_call:
    inputs:
      os:
        required: true
        type: string
      runs-on:
        required: true
        type: string
      builder-host:
        required: true
        type: string
      builder-target:
        required: true
        type: string
      target-vendor:
        required: true
        type: string
      target-os:
        required: true
        type: string
      rust-toolchain-abi:
        required: true
        type: string
      distro-image:
        required: true
        type: string
      distro-LLVM:
        required: true
        type: string
      rust-toolchain-name:
        required: true
        type: string
      build-profile:
        required: true
        type: string
      job-flavor:
        required: true
        type: string
    secrets:
      CODECOV_TOKEN:
      SONAR_TOKEN:
    outputs:
      rustfmt-artifact-url:
        value: ${{ jobs.linux.outputs.rustfmt-artifact-url }}

env:
  DEBIAN_FRONTEND: noninteractive
  RUSTFLAGS: "-Dwarnings"
  SRC_DIR: ${{ github.workspace }}/rawspeed.rs
  CODECOV_TOKEN_EXISTS: ${{ secrets.CODECOV_TOKEN != '' }}
  CODE_COVERAGE_SUPPORTED: ${{ inputs.job-flavor == 'plain' && (inputs.target-os != 'windows' || inputs.rust-toolchain-abi == 'msvc') }}
  WITH_CODEQL: ${{ inputs.builder-host != 'aarch64' && inputs.job-flavor == 'plain' }}
  WITH_SONARQUBE: ${{ secrets.SONAR_TOKEN != '' }}

jobs:
  linux:
    runs-on: ${{ inputs.runs-on }}
    name: ${{ inputs.runs-on }} (${{ inputs.builder-host }}, for ${{ inputs.builder-target}}) // ${{ inputs.distro-image }}, LLVM ${{ inputs.distro-LLVM }}, Rust ${{ inputs.rust-toolchain-name }}, profile ${{ inputs.build-profile }}, job flavor ${{ inputs.job-flavor }}
    container:
      image: ${{ inputs.distro-image }}
      options: --tmpfs /tmp:exec --tmpfs /__w/${{ github.event.repository.name }}/${{ github.event.repository.name }}:exec
    outputs:
      rustfmt-artifact-url: ${{ steps.rustfmt-upload.outputs.artifact-url }}
    steps:
      - name: Configure necessary env variables
        timeout-minutes: 1
        run: |
          set -xe
          WITH_CODE_COVERAGE=${{ env.CODE_COVERAGE_SUPPORTED == 'true' && (inputs.builder-host == inputs.builder-target || (env.ENDIANNESS == 'big' && inputs.builder-target != 's390x')) && (github.event_name == 'pull_request' || env.CODECOV_TOKEN_EXISTS == 'true') }}
          echo "WITH_CODE_COVERAGE=$(echo ${WITH_CODE_COVERAGE})" >> $GITHUB_ENV
          if    [ "${{ inputs.builder-target }}" = "x86_64" ]      \
             || [ "${{ inputs.builder-target }}" = "aarch64" ]     \
             || [ "${{ inputs.builder-target }}" = "i686" ]        \
             || [ "${{ inputs.builder-target }}" = "powerpc64" ]   \
             || [ "${{ inputs.builder-target }}" = "powerpc64le" ] \
             || [ "${{ inputs.builder-target }}" = "s390x" ]       \
             || [ "${{ inputs.builder-target }}" = "armv7" ];
          then
          RUST_TARGET_ARCH=${{ inputs.builder-target }}
          elif [ "${{ inputs.builder-target }}" = "armv6" ]; then
          RUST_TARGET_ARCH=arm
          elif [ "${{ inputs.builder-target }}" = "riscv64" ]; then
          RUST_TARGET_ARCH=riscv64gc
          else
          exit 1
          fi
          echo "RUST_TARGET_ARCH=$(echo ${RUST_TARGET_ARCH})" >> $GITHUB_ENV
          RUST_TARGET=${RUST_TARGET_ARCH}-${{ inputs.target-vendor }}-${{ inputs.target-os }}-${{ inputs.rust-toolchain-abi }}
          echo "RUST_TARGET=$(echo ${RUST_TARGET})" >> $GITHUB_ENV
          if [ "${{ inputs.builder-target }}" = "i686" ]; then
          LIBC6_ARCH=i386
          elif [ "${{ inputs.builder-target }}" = "powerpc64" ]; then
          LIBC6_ARCH=ppc64
          elif [ "${{ inputs.builder-target }}" = "powerpc64le" ]; then
          LIBC6_ARCH=ppc64el
          elif [ "${{ inputs.builder-target }}" = "armv6" ]; then
          LIBC6_ARCH=armel
          elif [ "${{ inputs.builder-target }}" = "armv7" ]; then
          LIBC6_ARCH=armhf
          else
          LIBC6_ARCH=${{ inputs.builder-target }}
          fi
          echo "LIBC6_ARCH=$(echo ${LIBC6_ARCH})" >> $GITHUB_ENV
          if [ "${{ inputs.builder-target }}" = "armv6" ]; then
          GCC_ARCH=arm
          elif [ "${{ inputs.builder-target }}" = "armv7" ]; then
          GCC_ARCH=arm
          else
          GCC_ARCH=${{ inputs.builder-target }}
          fi
          echo "GCC_ARCH=$(echo ${GCC_ARCH})" >> $GITHUB_ENV
          if    [ "${{ inputs.builder-target }}" = "s390x" ]      \
             || [ "${{ inputs.builder-target }}" = "powerpc64" ];
          then
          ENDIANNESS=big
          else
          ENDIANNESS=little
          fi
          echo "ENDIANNESS=$(echo ${ENDIANNESS})" >> $GITHUB_ENV
          echo HOME=/root >> "$GITHUB_ENV"
      - name: Configure APT
        timeout-minutes: 1
        run: |
          set -xe
          tee /etc/dpkg/dpkg.cfg.d/force-unsafe-io > /dev/null <<EOT
          force-unsafe-io
          EOT
          tee /etc/apt/apt.conf.d/tmpfs > /dev/null <<EOT
          Dir::Cache::Archives "/tmp/apt/archives";
          APT::ExtractTemplates::TempDir "/tmp/apt/temp";
          EOT
          mkdir -p /tmp/apt/archives
          tee /etc/apt/apt.conf.d/80retry > /dev/null <<EOT
          Acquire::Retries "10";
          EOT
          tee /etc/apt/apt.conf.d/80recommends > /dev/null <<EOT
          APT::Install-Recommends "false";
          EOT
          tee /etc/apt/apt.conf.d/80suggests > /dev/null <<EOT
          APT::Install-Suggests "false";
          EOT
          tee /etc/apt/apt.conf.d/80forceyes > /dev/null <<EOT
          APT::Get::Assume-Yes "true";
          EOT
          tee /etc/apt/apt.conf.d/80fixmissing > /dev/null <<EOT
          APT::Get::Fix-Missing "true";
          EOT
          rm -rf /etc/apt/sources.list*
          if [ "${{ inputs.distro-image }}" = "debian:trixie-slim" ]; then
          tee /etc/apt/sources.list > /dev/null <<EOT
          deb http://deb.debian.org/debian trixie main
          deb http://deb.debian.org/debian trixie-updates main
          deb http://deb.debian.org/debian-security trixie-security main
          deb http://deb.debian.org/debian trixie-backports main
          EOT
          else
            exit 1
          fi
      - name: Install eatmydata
        timeout-minutes: 1
        run: |
          set -xe
          rm -rf /var/lib/apt/lists/*
          apt update
          apt install eatmydata
          rm -rf /var/lib/apt/lists/*
      - name: Configure for native compilation
        timeout-minutes: 1
        run: |
          set -xe
          PACKAGES="${{ env.PACKAGES }}"
          PACKAGES="${PACKAGES} \
            ca-certificates \
            curl \
            git \
            gpg \
          "
          if    [ "${{ inputs.job-flavor }}" != "RustFmt" ] \
             && [ "${{ inputs.job-flavor }}" != "doc" ] \
             && [ "${{ inputs.job-flavor }}" != "SonarQube" ]; then
          PACKAGES="${PACKAGES} \
            clang-${{ inputs.distro-LLVM }} \
            lld-${{ inputs.distro-LLVM }} \
          "
          fi
          if [ "${{ inputs.job-flavor }}" = "SonarQube" ]; then
          PACKAGES="${PACKAGES} \
            curl unzip \
          "
          fi
          dpkg-divert --add --rename --divert /usr/bin/cc.original /usr/bin/cc
          dpkg-divert --add --rename --divert /usr/bin/gcc.original /usr/bin/gcc
          dpkg-divert --add --rename --divert /usr/bin/g++.original /usr/bin/g++
          dpkg-divert --add --rename --divert /usr/bin/ld.original /usr/bin/ld
          ln -s /usr/bin/clang-${{ inputs.distro-LLVM }} /usr/local/bin/clang
          ln -s /usr/bin/clang++-${{ inputs.distro-LLVM }} /usr/local/bin/clang++
          ln -s /usr/bin/ld.lld-${{ inputs.distro-LLVM }} /usr/local/bin/ld.lld
          ln -s /usr/bin/lld-link-${{ inputs.distro-LLVM }} /usr/local/bin/lld-link
          ln -s /usr/local/bin/clang /usr/local/bin/cc
          ln -s /usr/local/bin/clang /usr/local/bin/gcc
          ln -s /usr/local/bin/clang++ /usr/local/bin/c++
          ln -s /usr/local/bin/clang++ /usr/local/bin/g++
          ln -s /usr/local/bin/ld.lld /usr/local/bin/ld
          echo "PACKAGES=$(echo ${PACKAGES})" >> $GITHUB_ENV
      - name: Configure for same-os cross-arch compilation
        timeout-minutes: 1
        if: inputs.job-flavor == 'plain' && inputs.target-os == 'linux' && inputs.builder-host != inputs.builder-target
        run: |
          set -xe
          PACKAGES="${{ env.PACKAGES }}"
          PACKAGES="${PACKAGES} \
            gcc-${{ env.GCC_ARCH }}-${{ inputs.target-os }}-${{ inputs.rust-toolchain-abi }} \
            libc6-dev-${{ env.LIBC6_ARCH }}-cross \
            qemu-user \
            qemu-user-binfmt \
          "
          ln -s /usr/local/bin/clang /usr/local/bin/${{ inputs.builder-target }}-${{ inputs.target-vendor }}-${{ inputs.target-os }}-${{ inputs.rust-toolchain-abi }}-clang
          ln -s /usr/local/bin/clang++ /usr/local/bin/${{ inputs.builder-target }}-${{ inputs.target-vendor }}-${{ inputs.target-os }}-${{ inputs.rust-toolchain-abi }}-clang++
          ln -s /usr/local/bin/ld /usr/local/bin/${{ inputs.builder-target }}-${{ inputs.target-vendor }}-${{ inputs.target-os }}-${{ inputs.rust-toolchain-abi }}-ld
          LINKER="${{ inputs.builder-target }}-${{ inputs.target-vendor }}-${{ inputs.target-os }}-${{ inputs.rust-toolchain-abi }}-clang"
          if [ "${{ inputs.builder-target }}" = "powerpc64" ]; then
          # LLD/clang does not support powerpc64 ELFv1 ABI
          LINKER="${{ env.GCC_ARCH }}-${{ inputs.target-os }}-${{ inputs.rust-toolchain-abi }}-gcc"
          fi
          mkdir -p "$HOME/.cargo" && tee -a "$HOME/.cargo/config.toml" > /dev/null <<EOT
          [target.${{ env.RUST_TARGET }}]
          linker = "${LINKER}"
          EOT
          if [ "${{ inputs.builder-target }}" != "i686" ]; then
          mkdir -p "$HOME/.cargo" && tee -a "$HOME/.cargo/config.toml" > /dev/null <<EOT
          runner = "qemu-${{ env.LIBC6_ARCH }} -L /usr/${{ env.GCC_ARCH }}-${{ inputs.target-os }}-${{ inputs.rust-toolchain-abi }}"
          EOT
          fi
          if [ "${{ inputs.builder-target }}" = "i686" ]; then
          eatmydata dpkg --add-architecture i386
          PACKAGES="${PACKAGES} \
            libc6:i386 \
          "
          fi
          echo "PACKAGES=$(echo ${PACKAGES})" >> $GITHUB_ENV
      - name: Configure for cross-os same-arch compilation
        timeout-minutes: 1
        if: inputs.target-os == 'windows'
        run: |
          set -xe
          PACKAGES="${{ env.PACKAGES }}"
          if [ "${{ inputs.builder-target }}" = "i686" ]; then
          eatmydata dpkg --add-architecture i386
          fi
          if [ "${{ inputs.rust-toolchain-abi }}" = "gnu" ]; then
          PACKAGES="${PACKAGES} \
            mingw-w64 \
          "
          fi
          PACKAGES="${PACKAGES} \
            wine \
          "
          if [ "${{ inputs.builder-target }}" = "i686" ]; then
          PACKAGES="${PACKAGES} \
            wine32:i386 \
          "
          fi
          if [ "${{ inputs.rust-toolchain-abi }}" = "msvc" ]; then
          PACKAGES="${PACKAGES} \
            python3 msitools \
          "
          fi
          mkdir -p "$HOME/.cargo" && tee -a "$HOME/.cargo/config.toml" > /dev/null <<EOT
          [target.${{ env.RUST_TARGET }}]
          runner = "wine"
          EOT
          if [ "${{ inputs.rust-toolchain-abi }}" = "msvc" ]; then
          mkdir -p "$HOME/.cargo" && tee -a "$HOME/.cargo/config.toml" > /dev/null <<EOT
          linker = "lld-link"
          EOT
          fi
          echo "PACKAGES=$(echo ${PACKAGES})" >> $GITHUB_ENV
      - name: Install the packages
        timeout-minutes: 2
        run: |
          set -xe
          rm -rf /var/lib/apt/lists/*
          apt update
          eatmydata apt upgrade
          eatmydata apt install ${{ env.PACKAGES }}
          eatmydata apt clean
          rm -rf /var/lib/apt/lists/*
      - name: Install Rust toolchain and targets and crates
        timeout-minutes: 4
        run: |
          set -xe
          RUST_COMPONENTS=""
          RUST_CRATES=""
          eatmydata curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- --default-toolchain none --profile minimal -y
          . "$HOME/.cargo/env"
          eatmydata rustup toolchain install ${{ inputs.rust-toolchain-name }} --allow-downgrade --profile minimal
          eatmydata rustup default ${{ inputs.rust-toolchain-name }}
          eatmydata rustup target add ${{ env.RUST_TARGET }}
          if [ "${{ inputs.job-flavor }}" = "RustFmt" ]; then
          RUST_COMPONENTS="${RUST_COMPONENTS} \
            rustfmt \
          "
          elif [ "${{ inputs.job-flavor }}" = "doc" ]; then
          /bin/true
          elif [ "${{ inputs.job-flavor }}" = "SonarQube" ]; then
          /bin/true
          elif [ "${{ inputs.job-flavor }}" = "plain" ]; then
          RUST_COMPONENTS="${RUST_COMPONENTS} \
            clippy \
          "
          elif [ "${{ inputs.job-flavor }}" = "Miri" ]; then
          RUST_COMPONENTS="${RUST_COMPONENTS} \
            rust-src \
            miri \
          "
          RUST_CRATES="${RUST_CRATES} \
            cargo-nextest \
          "
          elif    [ "${{ inputs.job-flavor }}" = "ASAN" ] \
               || [ "${{ inputs.job-flavor }}" = "MSAN" ] \
               || [ "${{ inputs.job-flavor }}" = "TSAN" ]; then
          RUST_COMPONENTS="${RUST_COMPONENTS} \
            rust-src \
          "
          else
          exit 1
          fi
          if [ "${{ env.WITH_CODE_COVERAGE }}" = "true" ]; then
          RUST_COMPONENTS="${RUST_COMPONENTS} \
            llvm-tools-preview \
          "
          RUST_CRATES="${RUST_CRATES} \
            cargo-llvm-cov \
          "
          fi
          if [ "${RUST_COMPONENTS}" != "" ]; then
          eatmydata rustup component add ${RUST_COMPONENTS}
          fi
          if [ "${RUST_CRATES}" != "" ]; then
          eatmydata cargo install ${RUST_CRATES}
          fi
      - name: Fetch/Checkout msvc-wine git repo
        timeout-minutes: 1
        if: inputs.target-os == 'windows' && inputs.rust-toolchain-abi == 'msvc'
        uses: actions/checkout@v4
        with:
          repository: 'mstorsjo/msvc-wine'
          path: 'msvc-wine'
          fetch-depth: 1
          set-safe-directory: ${{ github.workspace }}
      - name: Perform msvc-wine stuff
        timeout-minutes: 2
        if: inputs.target-os == 'windows' && inputs.rust-toolchain-abi == 'msvc'
        run: |
          set -xe
          . "$HOME/.cargo/env"
          cd msvc-wine
          if [ "${{ inputs.builder-target }}" = "x86_64" ]; then
          MSVC_ARCH=x64
          elif [ "${{ inputs.builder-target }}" = "i686" ]; then
          MSVC_ARCH=x86
          elif [ "${{ inputs.builder-target }}" = "aarch64" ]; then
          MSVC_ARCH=arm64
          else
          exit 1
          fi
          PYTHONUNBUFFERED=1 ./vsdownload.py --accept-license --dest /opt/msvc
          ./install.sh /opt/msvc
          tee -a "$HOME/.cargo/env" > /dev/null <<EOT
          BIN=/opt/msvc/bin/${MSVC_ARCH} . $(pwd)/msvcenv-native.sh
          EOT
      - name: Fetch/Checkout RawSpeed.RS git repo
        timeout-minutes: 1
        uses: actions/checkout@v4
        with:
          path: 'rawspeed.rs'
          fetch-depth: 0  # Shallow clones should be disabled for a better relevancy of analysis
          set-safe-directory: ${{ github.workspace }}
      - name: Fetch/Checkout RawSpeed.cpp git repo
        timeout-minutes: 1
        uses: actions/checkout@v4
        with:
          repository: 'darktable-org/rawspeed'
          path: 'rawspeed'
          sparse-checkout: |
            data/cameras.xml
          fetch-depth: 1
          set-safe-directory: ${{ github.workspace }}
      - name: Switch to the Pull Request's merge commit
        timeout-minutes: 1
        if: github.event_name == 'pull_request_target'
        env:
          PR: ${{ github.event.number }}
        run: |
          set -xe
          cd rawspeed.rs
          git fetch origin pull/${PR}/merge:pr/${PR}/merge
          git switch pr/${PR}/merge
      - name: Initialize CodeQL (for CodeQL static analysis)
        timeout-minutes: 1
        if: env.WITH_CODEQL == 'true'
        uses: github/codeql-action/init@v3
        with:
          source-root: ${{ env.SRC_DIR}}
          languages: rust
      - name: Verify that the source code is properly formatted
        id: rustfmt
        timeout-minutes: 1
        if: inputs.job-flavor == 'RustFmt'
        run: |
          set -xe
          . "$HOME/.cargo/env"
          cd "$SRC_DIR"
          cargo fmt --all
          git diff -p -U8 > "${GITHUB_WORKSPACE}/rustfmt.patch"
          git diff --stat --exit-code
      - name: Upload rustfmt patch
        id: rustfmt-upload
        timeout-minutes: 1
        if: inputs.job-flavor == 'RustFmt' && failure() && steps.rustfmt.conclusion == 'failure'
        uses: actions/upload-artifact@v4
        with:
          name: rustfmt.patch
          path: ${{ github.workspace }}/rustfmt.patch
          if-no-files-found: error
          compression-level: 9
          overwrite: true
      - name: Run cargo check
        timeout-minutes: 1
        if: inputs.job-flavor == 'plain'
        run: |
          set -xe
          . "$HOME/.cargo/env"
          cd "$SRC_DIR"
          cargo check --target ${{ env.RUST_TARGET }} --profile ${{ inputs.build-profile }} --all-targets --all-features
      - name: Run Clippy
        timeout-minutes: 1
        if: inputs.job-flavor == 'plain'
        run: |
          set -xe
          . "$HOME/.cargo/env"
          cd "$SRC_DIR"
          cargo clippy --target ${{ env.RUST_TARGET }} --profile ${{ inputs.build-profile }} --all-targets --all-features
      - name: Build
        timeout-minutes: 1
        if: inputs.job-flavor == 'plain'
        run: |
          set -xe
          . "$HOME/.cargo/env"
          cd "$SRC_DIR"
          cargo build --target ${{ env.RUST_TARGET }} --profile ${{ inputs.build-profile }}
      - name: Run tests
        timeout-minutes: 2
        if: inputs.job-flavor == 'plain'
        run: |
          set -xe
          . "$HOME/.cargo/env"
          cd "$SRC_DIR"
          cargo test --target ${{ env.RUST_TARGET }} --profile ${{ inputs.build-profile }}
      - name: Run tests to collect code coverage
        timeout-minutes: 2
        if: env.WITH_CODE_COVERAGE == 'true'
        env:
          RUSTFLAGS: "-C instrument-coverage"
        run: |
          set -xe
          . "$HOME/.cargo/env"
          cd "$SRC_DIR"
          cargo clean
          cargo llvm-cov --no-report --target ${{ env.RUST_TARGET }} --profile ${{ inputs.build-profile }}
      - name: Aggregate code coverage
        timeout-minutes: 1
        if: env.WITH_CODE_COVERAGE == 'true'
        run: |
          set -xe
          . "$HOME/.cargo/env"
          cd "$SRC_DIR"
          cargo llvm-cov report --codecov --output-path $SRC_DIR/codecov.json --target ${{ env.RUST_TARGET }} --profile ${{ inputs.build-profile }}
      - name: Upload coverage reports to Codecov
        timeout-minutes: 1
        if: env.WITH_CODE_COVERAGE == 'true'
        uses: codecov/codecov-action@v5
        env:
          OS: ${{ inputs.os }}
          BUILDER_HOST: ${{ inputs.builder-host }}
          BUILDER_TARGET: ${{ inputs.builder-target }}
          RUST_TOOLCHAIN: ${{ env.RUST_TARGET }}
          LLVM_VER: ${{ inputs.distro-LLVM }}
          RUST_PROFILE: ${{ inputs.build-profile }}
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          env_vars: OS,BUILDER_HOST,BUILDER_TARGET,ENDIANNESS,RUST_TOOLCHAIN,LLVM_VER,RUST_PROFILE
          flags: ${{ env.OS }}, host=${{ env.BUILDER_HOST }}, target=${{ env.BUILDER_TARGET }}, endianness=${{ env.ENDIANNESS }}, rust=${{ env.RUST_TOOLCHAIN }}, LLVM=${{ env.LLVM_VER }}, profile=${{ env.RUST_PROFILE }}
          files: ${{ env.SRC_DIR }}/codecov.json
          root_dir: ${{ env.SRC_DIR }}
          fail_ci_if_error: true
      - name: Run tests under Miri
        timeout-minutes: 11
        if: inputs.job-flavor == 'Miri'
        run: |
          set -xe
          . "$HOME/.cargo/env"
          cd "$SRC_DIR"
          cargo miri nextest run --target ${{ env.RUST_TARGET }}
      - name: Run tests under Sanitizer
        timeout-minutes: 2
        if: inputs.job-flavor == 'ASAN' || inputs.job-flavor == 'MSAN' || inputs.job-flavor == 'TSAN'
        run: |
          set -xe
          . "$HOME/.cargo/env"
          BUILD_ARGS="${BUILD_ARGS} -Z build-std"
          if [ "${{ inputs.job-flavor }}" = "ASAN" ]; then
          FLAGS="${FLAGS} -Zsanitizer=address"
          elif [ "${{ inputs.job-flavor }}" = "MSAN" ]; then
          FLAGS="${FLAGS} -Zsanitizer=memory -Zsanitizer-memory-track-origins"
          elif [ "${{ inputs.job-flavor }}" = "TSAN" ]; then
          FLAGS="${FLAGS} -Zsanitizer=thread"
          else
          exit 1
          fi
          export RUSTFLAGS="$RUSTFLAGS $FLAGS"
          export RUSTDOCFLAGS="$RUSTDOCFLAGS $FLAGS"
          export ${{ inputs.job-flavor }}_OPTIONS="allocator_may_return_null=1"
          cd "$SRC_DIR"
          cargo test --all-targets $BUILD_ARGS --target ${{ env.RUST_TARGET }} --profile ${{ inputs.build-profile }}-sanitized
      - name: Perform CodeQL static analysis
        timeout-minutes: 5
        if: env.WITH_CODEQL == 'true'
        uses: github/codeql-action/analyze@v3
        with:
          source-root: ${{ env.SRC_DIR}}
          checkout_path: ${{ env.SRC_DIR}}
      - name: Perform SonarQube static analysis
        timeout-minutes: 1
        if: inputs.job-flavor == 'SonarQube' && env.WITH_SONARQUBE == 'true'
        uses: SonarSource/sonarqube-scan-action@v5
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        with:
          args: >
            --define sonar.organization=darktable-org
            --define sonar.projectKey=darktable-org_rawspeed-rs
            --define sonar.projectBaseDir=rawspeed.rs
            --define sonar.sources=.
      - name: Build docs
        timeout-minutes: 1
        if: inputs.job-flavor == 'doc'
        run: |
          set -xe
          . "$HOME/.cargo/env"
          cd "$SRC_DIR"
          cargo doc
          if [ ! -f $SRC_DIR/target/doc/index.* ]; then
          tee $SRC_DIR/target/doc/index.html > /dev/null <<EOT
          <head>
          <meta http-equiv="Refresh" content="0; URL=./rawspeed/index.html" />
          </head>
          EOT
          fi
      - name: Upload docs artifact
        timeout-minutes: 1
        if: inputs.job-flavor == 'doc'
        uses: actions/upload-pages-artifact@v3
        with:
          path: ${{ github.workspace }}/rawspeed.rs/target/doc
